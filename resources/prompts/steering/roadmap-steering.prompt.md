# Implementation Roadmap Generation Prompt

You are generating an implementation roadmap for an Agentify project. This roadmap contains **items**, each with a prompt that a user will copy into Kiro IDE chat. Kiro will then generate a `spec.md` file from that prompt, followed by requirements, design, tasks, and implementation.

## Critical Architecture Requirement

**Every prompt you generate MUST embed the AgentCore architecture context.** This is non-negotiable because Kiro processes each item independently and will not remember architecture from previous items or steering files.

The architecture is:
- Agents deploy to **Amazon Bedrock AgentCore Runtime** via AgentCore CLI — they run remotely, NOT locally
- Only `agents/main.py` runs locally — it is the orchestrator that calls remote agents
- Use **Strands SDK**: `from strands import Agent, tool`
- All integrations are **mock tools** (this is a demo system, not production)
- Emit events to DynamoDB + stdout for Demo Viewer visualization

## Input Context

You will receive the following steering files as XML blocks:

```xml
<tech_md>
{content of .kiro/steering/tech.md}
</tech_md>

<structure_md>
{content of .kiro/steering/structure.md}
</structure_md>

<integration_landscape_md>
{content of .kiro/steering/integration-landscape.md}
</integration_landscape_md>

<agentify_integration_md>
{content of .kiro/steering/agentify-integration.md}
</agentify_integration_md>
```

## Your Task

Generate a markdown file called `roadmap.md` with the following structure:

### 1. How to Use This Roadmap (Section)

Write clear instructions explaining:
- This roadmap contains numbered items, each with a prompt for Kiro
- User copies the prompt and pastes it into Kiro chat
- Kiro generates `spec.md`, then requirements, design, tasks, and implements
- User verifies the acceptance criteria on the implemented code
- Move to next item and repeat

### 2. Architecture Context (Section)

Extract and document the core architecture from `tech.md`:
- Deployment model (local main.py → remote AgentCore agents)
- SDK requirements (Strands)
- Event emission patterns (stdout for graph, DynamoDB for tools)
- Mock tool strategy

Format this as a blockquote that users can reference. This same context is embedded in every item's prompt.

### 3. Pre-existing CDK Infrastructure (Section)

**CRITICAL:** The project includes a pre-existing CDK folder structure that Kiro must NOT modify. Explain this clearly:

```
cdk/                              # PRE-EXISTING — DO NOT MODIFY
├── app.py                        # CDK entry point
├── config.py                     # Environment configuration
├── stacks/
│   ├── networking.py             # VPC, endpoints, security groups
│   ├── observability.py          # DynamoDB table
│   └── gateway_tools.py          # Auto-discovers handlers (Python)
└── gateway/
    └── handlers/                 # EMPTY — Kiro populates this
```

The `gateway_tools.py` stack automatically discovers any handlers in `cdk/gateway/handlers/*/` during deployment. Kiro's job is to CREATE handler directories inside this existing structure.

### 4. Pre-bundled Files (Explain This)

**CRITICAL:** The following files are **pre-bundled** by the Agentify extension. Kiro should NOT recreate these files — they already exist:

**Shared Utilities** (`agents/shared/`):
- `agents/shared/__init__.py` — Module exports
- `agents/shared/instrumentation.py` — `@instrument_tool` decorator for observability
- `agents/shared/dynamodb_client.py` — Fire-and-forget event persistence
- `agents/shared/gateway_auth.py` — `GatewayTokenManager` for OAuth
- `agents/shared/orchestrator_utils.py` — CLI parsing, event emission, remote agent invocation

**Orchestrator** (`agents/main.py`):
- `agents/main.py` — Pattern-specific orchestrator template (Graph, Swarm, or Workflow)
  - Contains: CLI parsing, event emission, `invoke_agent_remotely()`, error handling
  - Kiro modifies: CUSTOMIZATION SECTION only (4 functions)

Explain this clearly in the roadmap so users know:
- IMPORT from `agents/shared/` modules, not recreate them
- MODIFY `agents/main.py` CUSTOMIZATION SECTION, not recreate the entire file

### 5. Cedar Policies & Policy Engine (If Generated)

**CONDITIONAL:** This section is ONLY included if the project has a `policies/` directory with Cedar policy files. Check if `policies/main.cedar` exists before including this section.

Cedar policies are generated by Agentify during Step 8 when security configuration (Step 4) includes compliance frameworks or approval gates. The policies enforce access control rules for agent actions.

**What Gets Generated:**
- `policies/main.cedar` — Cedar policies based on Step 4 security inputs
- Policies include: data sensitivity rules, compliance requirements, approval gate enforcement

**Policy Engine Setup (Handled by setup.sh):**
The `setup.sh` script handles Policy Engine creation and association:

1. **Step 2b in setup.sh** (after CDK deploy, before agent deploy):
   - Creates Policy Engine via `agentcore policy create-policy-engine`
   - Loads Cedar policies from `policies/*.cedar`
   - Associates Policy Engine with MCP Gateway

**Roadmap Inclusion:**
If Cedar policies exist, add a note in the "How to Use This Roadmap" section:

```markdown
**Note:** This project includes Cedar policies in `policies/`. The Policy Engine is automatically
created and associated with the MCP Gateway during `./scripts/setup.sh` deployment (Step 2b).
No Kiro items are needed for Policy Engine setup.
```

**Important:** Policy Engine creation is an infrastructure concern handled by `setup.sh`, NOT a Kiro implementation item. Do NOT generate a separate roadmap item for Policy Engine setup.

### 6. Roadmap Items (Multiple Sections)

Generate items in this order:

#### Item 1: Gateway Lambda Handlers (Shared Tools) — if any shared tools exist
- Prompt for Kiro to create Python Lambda handlers by **injecting them into the existing CDK structure**
- Path: `cdk/gateway/handlers/{tool_name}/handler.py` (MUST be inside `cdk/` folder)
- Each handler directory contains its own `mock_data.json` (bundled with Lambda at deploy time)
- Each handler parses tool name from context, loads its bundled mock data, returns JSON
- NOTE: The CDK stack (`cdk/stacks/gateway_tools.py`) already exists — Kiro does NOT create or modify it
- NOTE: Gateway setup scripts already exist — Kiro does NOT create them
- Acceptance: Handler files exist in correct path, `cdk deploy` succeeds (auto-discovers handlers)

#### Items 2-N: One Item Per Agent
For each agent in the design:
- Prompt for Kiro to create agent module: `agents/{agent_id}/` with agent.py, prompts.py, tools/
- Prompt for Kiro to create handler: `agents/{agent_id}_handler.py` (AgentCore entry point)
- LOCAL tools defined with BOTH decorators: `@tool` ON TOP, `@instrument_tool` BELOW (closest to function)
- SHARED tools accessed via Gateway MCP client (not imported locally)
- MUST mention AgentCore deployment in the prompt
- MUST require importing @instrument_tool from `agents.shared.instrumentation` (pre-bundled)
- Each agent depends on Item 1 (Gateway handlers) if using shared tools

#### Final Item: Main Orchestrator Customization (Pattern-Specific)

**IMPORTANT:** Generate this item based on `confirmedOrchestration` from wizard-state.json.

**Graph Pattern** (`confirmedOrchestration == "graph"`):
- CUSTOMIZATION SECTION functions: `define_graph_structure()`, `get_entry_agent()`, `route_to_next_agent()`, `get_agent_display_name()`
- Routing uses `CLASSIFICATION_ROUTES` or `STATIC_ROUTES` dicts (NO keyword matching)
- Agent prompts MUST return `route_to` or `classification` field for non-static routing

**Swarm Pattern** (`confirmedOrchestration == "swarm"`):
- CUSTOMIZATION SECTION functions: `define_graph_structure()`, `get_entry_agent()`, `get_agent_display_name()`
- Agents decide handoffs autonomously via `handoff_to_agent` tool or `handoff_to` response field
- Each agent item MUST include the `handoff_to_agent` tool definition

**Workflow Pattern** (`confirmedOrchestration == "workflow"`):
- CUSTOMIZATION SECTION functions: `define_graph_structure()`, `define_task_dag()`, `get_agent_display_name()`, `build_task_prompt()`
- DAG determines execution order — agents do NOT need routing fields
- Tasks run in parallel when their dependencies are satisfied

- Acceptance: Running main.py produces stdout events, CUSTOMIZATION SECTION is filled in

### Per-Item Format

Each roadmap item MUST follow this exact format:

```markdown
## Item N: {Name}

**Purpose:** {one-line description of what Kiro will build}

**Depends on:** {comma-separated list of item numbers, or "None"}

**Files to be created:**
- `{path/to/file.py}` — {description}

**Prompt for Kiro — Copy everything in the code block below and paste into Kiro chat:**

\`\`\`
{Full prompt text — see template below}
\`\`\`

**Acceptance Criteria (verify after Kiro implements):**
- [ ] {Specific, testable verification step}
- [ ] {Another verification step}
```

### Prompt Template

Every prompt MUST include this architecture context block at the top. **Customize sections 6-7 based on item type:**

```
Create {description of what to create}.

## CRITICAL ARCHITECTURE — READ BEFORE GENERATING CODE

This is an Agentify demo project. Follow these rules strictly:

1. **Agent Deployment**: Agents deploy to Amazon Bedrock AgentCore Runtime via `agentcore deploy`. They run REMOTELY, not locally.

2. **Local Orchestrator Only**: Only `agents/main.py` runs locally. It orchestrates by calling remote agents.

3. **Strands SDK**: Use `from strands import Agent, tool` for agent and tool definitions.

4. **Mock Tools**: All integrations are mocks returning realistic fake data. This is a demo system.

5. **Event Emission**: Emit events per .kiro/steering/agentify-integration.md:
   - DynamoDB writes for tool_call events via @instrument_tool decorator
   - Tools are instrumented with @instrument_tool for observability

6. **Decorator Order for Tools**: `@tool` must be ON TOP, `@instrument_tool` BELOW (closest to function):
   ```python
   @tool                    # ON TOP = outer wrapper (Strands SDK)
   @instrument_tool         # BELOW = inner wrapper (captures events)
   def my_tool():
       ...
   ```
   Python applies decorators bottom-up, so `@instrument_tool` wraps first, then `@tool` registers.

7. **Pre-existing CDK Structure**: The project has a pre-built CDK folder. Do NOT create or modify:
   - `cdk/stacks/*.py` — infrastructure stacks (already exist)
   - `cdk/app.py`, `cdk/config.py` — CDK configuration (already exist)
   - Gateway setup scripts (already exist)

8. **Where to Create Files** (and what's pre-bundled):
   - Shared utilities: `agents/shared/` — PRE-BUNDLED, import only (instrumentation, DynamoDB client, gateway_auth)
   - Gateway Lambda handlers: `cdk/gateway/handlers/{tool_name}/` (inject into existing CDK structure)
   - Agent modules: `agents/{agent_id}/` (agent.py, prompts.py, tools/)
   - Agent handlers: `agents/{agent_id}_handler.py` (AgentCore entry points)
   - Local orchestrator: `agents/main.py`

Reference these steering files:
- .kiro/steering/tech.md — deployment architecture
- .kiro/steering/agentify-integration.md — event contracts
- .kiro/steering/integration-landscape.md — tool definitions and mock data

## Requirements

{Specific requirements for what Kiro should build}
```

## Parsing Instructions

From `integration-landscape.md`, extract:
- Agent names
- Tools per agent (as a list)
- Mock data schemas per tool

From `tech.md`, extract:
- Orchestration pattern (graph/swarm/workflow)
- Deployment commands
- SDK imports

From `agentify-integration.md`, extract:
- CLI argument contract
- Environment variable names
- Event schemas for stdout and DynamoDB

From `structure.md`, extract:
- File organization pattern
- Folder structure

## Example Output Structure

```markdown
# Implementation Roadmap

## How to Use This Roadmap

This roadmap guides you through building your Agentify demo project step by step using Kiro IDE.

**Workflow for each item:**

1. Read the item's **Purpose** and **Files to be created**
2. Copy the **Prompt for Kiro** (everything in the code block)
3. Paste into Kiro chat
4. Kiro creates spec.md → requirements.md → design.md → tasks.md → implementation
5. Verify the **Acceptance Criteria** on the implemented code
6. Move to the next item

**Important:** Complete items in order — later items depend on earlier ones.

---

## Architecture Context

> **Core Architecture (embedded in every prompt):**
>
> - Agents deploy to **Amazon Bedrock AgentCore Runtime** via AgentCore CLI
> - Only `agents/main.py` runs locally — it orchestrates remote agents
> - Use **Strands SDK**: `from strands import Agent, tool`
> - All integrations are **mock tools** (demo system)
> - Emit events to DynamoDB + stdout for Demo Viewer visualization
>
> If Kiro generates code that runs agents locally or skips AgentCore deployment, ask it to correct this.

---

## Pre-existing CDK Infrastructure

The project includes a pre-built CDK folder structure. **Do NOT modify these files:**

```
cdk/                              # PRE-EXISTING — DO NOT MODIFY
├── app.py                        # CDK entry point
├── config.py                     # Environment configuration
├── stacks/
│   ├── networking.py             # VPC, endpoints, security groups
│   ├── observability.py          # DynamoDB table
│   └── gateway_tools.py          # Auto-discovers handlers (Python)
└── gateway/
    └── handlers/                 # EMPTY — Kiro populates this directory
```

**How auto-discovery works:** The `gateway_tools.py` stack scans `cdk/gateway/handlers/*/` during deployment. Any directory containing a `handler.py` file becomes a Lambda function. Kiro's job is to CREATE new handler directories inside this existing structure.

---

## Pre-bundled Files

The following files are **pre-bundled** by the Agentify extension during project initialization. Do NOT recreate them:

### Shared Utilities (`agents/shared/`)

| File | Purpose | Import Example |
|------|---------|----------------|
| `agents/shared/instrumentation.py` | `@instrument_tool` decorator | `from agents.shared.instrumentation import instrument_tool` |
| `agents/shared/dynamodb_client.py` | Fire-and-forget event persistence | `from agents.shared.dynamodb_client import write_tool_event` |
| `agents/shared/gateway_auth.py` | OAuth token management | `from agents.shared.gateway_auth import GatewayTokenManager` |
| `agents/shared/orchestrator_utils.py` | CLI, events, SDK calls | `from agents.shared.orchestrator_utils import invoke_agent_remotely` |

### Main Orchestrator (`agents/main.py`)

The `agents/main.py` orchestrator is **pre-bundled** based on the selected orchestration pattern (Graph, Swarm, or Workflow).

| Section | Status | Description |
|---------|--------|-------------|
| GENERIC INFRASTRUCTURE | DO NOT MODIFY | CLI parsing, event emission, boto3 SDK calls, error handling |
| CUSTOMIZATION SECTION | MODIFY | 4 functions that define project-specific behavior |

Functions to implement in CUSTOMIZATION SECTION:
| Function | Purpose |
|----------|---------|
| `define_graph_structure()` | Return graph nodes/edges for Demo Viewer visualization |
| `get_entry_agent()` | Return ID of first agent to invoke |
| `route_to_next_agent()` | Return next agent ID based on response, or None if complete |
| `get_agent_display_name()` | Return human-readable name for agent ID |

All agents should **import from** shared modules, and Kiro should **modify only the CUSTOMIZATION SECTION** of main.py.

---

## Item 1: Gateway Lambda Handlers (Shared Tools)

**Purpose:** Create Python Lambda handlers for shared tools by injecting them into the existing CDK structure.

**Depends on:** None (shared utilities are pre-bundled)

**Files to be created (inject into existing CDK structure):**
- `cdk/gateway/handlers/zendesk_get_ticket/handler.py` — Lambda handler (Python 3.11)
- `cdk/gateway/handlers/zendesk_get_ticket/requirements.txt` — Dependencies (if needed)
- `cdk/gateway/handlers/zendesk_get_ticket/mock_data.json` — Mock data bundled with Lambda
- (Repeat for each shared tool defined in integration-landscape.md)

**Pre-built files (do NOT create or modify):**
- `cdk/stacks/gateway_tools.py` — Auto-discovers and deploys handlers
- `cdk/gateway/setup_gateway.py` — Creates Gateway and registers targets
- `cdk/gateway/cleanup_gateway.py` — Tears down Gateway resources

**Prompt for Kiro — Copy everything in the code block below and paste into Kiro chat:**

\`\`\`
Create Lambda handlers for shared tools by injecting them into the existing CDK folder structure.

## CRITICAL ARCHITECTURE — READ BEFORE GENERATING CODE

This is an Agentify demo project. Follow these rules strictly:

1. **Inject Into Existing CDK Structure**: The CDK infrastructure already exists. You are ONLY creating handler directories inside `cdk/gateway/handlers/`. Do NOT create or modify any files in `cdk/stacks/`.

2. **Exact Path**: Create handlers at `cdk/gateway/handlers/{tool_name}/` — the `cdk/` prefix is required.

3. **Auto-Discovery**: The pre-existing `cdk/stacks/gateway_tools.py` automatically discovers any directory in `cdk/gateway/handlers/` that contains a `handler.py` file. It deploys each as a Lambda function.

4. **Mock Data Bundling**: Each handler directory MUST contain its own `mock_data.json` file. This file is bundled with the Lambda at deploy time. Do NOT reference external paths like `../../mocks/` — Lambda cannot access files outside its deployment package.

5. **Lambda Handler Pattern**: Gateway passes tool name with target prefix. Parse using:
   ```python
   delimiter = "___"
   tool_name = context.client_context.custom.get('bedrockAgentCoreToolName', '')
   if delimiter in tool_name:
       tool_name = tool_name[tool_name.index(delimiter) + len(delimiter):]
   ```

Reference:
- .kiro/steering/integration-landscape.md for shared tools list and mock data schemas
- .kiro/steering/tech.md for Gateway Lambda patterns

## Requirements

### 1. Lambda Handler Directories (Python 3.11)
For each shared tool in integration-landscape.md, create `cdk/gateway/handlers/{tool_name}/` containing:

**handler.py** — Lambda handler:
```python
import json
import os

def lambda_handler(event, context):
    # Parse tool name from Gateway context
    delimiter = "___"
    tool_name = context.client_context.custom.get('bedrockAgentCoreToolName', '')
    if delimiter in tool_name:
        tool_name = tool_name[tool_name.index(delimiter) + len(delimiter):]

    # Load mock data bundled with this Lambda
    mock_file = os.path.join(os.path.dirname(__file__), 'mock_data.json')
    with open(mock_file) as f:
        mock_data = json.load(f)

    # Process input from event
    input_params = event  # event contains the tool input parameters

    # Return mock response (customize based on tool logic)
    return json.dumps({"status": "success", "data": mock_data})
```

**mock_data.json** — Realistic sample data for this specific tool:
```json
{
    "records": [
        {"id": "1", "field": "value"},
        {"id": "2", "field": "value"}
    ]
}
```

**requirements.txt** — Only if dependencies beyond boto3 are needed (often empty)

### 2. Directory Structure After Implementation
```
cdk/gateway/handlers/
├── zendesk_get_ticket/
│   ├── handler.py
│   ├── mock_data.json
│   └── requirements.txt
├── zendesk_get_comments/
│   ├── handler.py
│   ├── mock_data.json
│   └── requirements.txt
└── customer_lookup/
    ├── handler.py
    ├── mock_data.json
    └── requirements.txt
```

### 3. What NOT to Create
- Do NOT create `cdk/stacks/*.py` files — they already exist
- Do NOT create `cdk/app.py` or `cdk/config.py` — they already exist
- Do NOT create gateway setup scripts — they already exist
- Do NOT create a separate `mocks/` directory — mock data goes inside each handler directory
\`\`\`

**Acceptance Criteria (verify after Kiro implements):**
- [ ] `cdk/gateway/handlers/{tool_name}/handler.py` exists for each shared tool
- [ ] `cdk/gateway/handlers/{tool_name}/mock_data.json` exists with realistic sample data
- [ ] Handler code loads mock data from same directory (not external path)
- [ ] Handler code uses the correct tool name parsing pattern
- [ ] `cd cdk && cdk deploy` succeeds (auto-discovers all handlers)
- [ ] No files in `cdk/stacks/` were created or modified

---

## Item 2: Ticket Analyzer Agent

**Purpose:** Create the Ticket Analyzer agent with local tools and Gateway connection.

**Depends on:** Item 1 (Gateway Lambda Handlers must be deployed first), Pre-bundled shared utilities

**Files to be created:**
- `agents/ticket_analyzer.py` — Agent with local and Gateway tools
- `agents/mock_data/ticket_analyzer/sentiment_responses.json` — Mock data for local tools (optional)

**Prompt for Kiro — Copy everything in the code block below and paste into Kiro chat:**

\`\`\`
Create the Ticket Analyzer agent for an Agentify demo project.

## CRITICAL ARCHITECTURE — READ BEFORE GENERATING CODE

This is an Agentify demo project. Follow these rules strictly:

1. **Agent Deployment**: Agents deploy to Amazon Bedrock AgentCore Runtime via `agentcore deploy`. They run REMOTELY, not locally.

2. **Local Orchestrator Only**: Only `agents/main.py` runs locally. It orchestrates by calling remote agents.

3. **Strands SDK**: Use `from strands import Agent, tool` for agent and tool definitions.

4. **Two Tool Types**:
   - LOCAL tools: Defined inline with @tool decorator (agent-specific, mock data embedded or in `agents/mock_data/`)
   - SHARED tools: Loaded from Gateway via MCP client (Lambda handlers in `cdk/gateway/handlers/`)

5. **Event Emission**: Emit events per .kiro/steering/agentify-integration.md

6. **Pre-existing Infrastructure**: Gateway Lambda handlers already exist in `cdk/gateway/handlers/`. Do NOT recreate them.

Reference these steering files:
- .kiro/steering/tech.md — deployment architecture and Gateway patterns
- .kiro/steering/agentify-integration.md — event contracts
- .kiro/steering/integration-landscape.md — tool definitions (local vs shared)

## Requirements

Create `agents/ticket_analyzer.py` with:

1. **Agent Definition** using Strands SDK:
   - Name: "Ticket Analyzer"
   - Role: Analyzes incoming support tickets for sentiment, urgency, and classification

2. **LOCAL Tools** (defined inline with @tool, only this agent uses them):
   - `aiml_analyze_sentiment(text: str) -> dict` — Returns mock sentiment analysis
   - `aiml_classify_text(text: str, categories: list) -> str` — Returns mock classification
   - Mock data can be embedded directly in the tool function or loaded from `agents/mock_data/`

3. **SHARED Tools** (loaded from Gateway, Lambda handlers already exist in `cdk/gateway/handlers/`):
   ```python
   from strands.tools.mcp import MCPClient
   from mcp.client.streamable_http import streamablehttp_client

   def get_gateway_tools(gateway_url: str, access_token: str) -> list:
       client = MCPClient(lambda: streamablehttp_client(
           gateway_url,
           headers={"Authorization": f"Bearer {access_token}"}
       ))
       with client:
           return client.list_tools_sync()
   ```
   - zendesk_get_ticket, zendesk_get_ticket_comments, ecommerce_get_customer_orders come from Gateway

4. Agent combines local + shared tools: `Agent(tools=local_tools + shared_tools)`

5. Agent emits events to DynamoDB for tool calls

This agent deploys to AgentCore Runtime. Include a comment with the deployment command:
# Deploy: agentcore deploy agents/ticket_analyzer.py
\`\`\`

**Acceptance Criteria (verify after Kiro implements):**
- [ ] `agents/ticket_analyzer.py` exists with Agent class
- [ ] Local tools (aiml_*) defined with @tool decorator returning mock data
- [ ] Shared tools loaded from Gateway via MCP client
- [ ] `agentcore deploy agents/ticket_analyzer.py` succeeds
- [ ] Both local and shared tools work when agent is invoked

---

... [continue pattern for remaining items] ...

## Item N: Main Orchestrator Customization

**IMPORTANT:** Generate this item based on `confirmedOrchestration` from wizard-state.json. Use the appropriate pattern-specific section below.

---

### IF confirmedOrchestration == "graph":

**Purpose:** Customize the pre-bundled Graph orchestrator with project-specific routing logic.

**Depends on:** Items 1 through N-1

**Files to be MODIFIED (not created):**
- `agents/main.py` — PRE-BUNDLED Graph orchestrator, customize CUSTOMIZATION SECTION only

**Prompt for Kiro — Copy everything in the code block below and paste into Kiro chat:**

\`\`\`
Customize the pre-bundled Graph orchestrator for this Agentify project.

## CRITICAL: DO NOT RECREATE agents/main.py

The `agents/main.py` file is **PRE-BUNDLED** by the Agentify extension.
It already contains CLI parsing, event emission, and `invoke_agent_remotely()`.

**You ONLY need to modify the CUSTOMIZATION SECTION** — the 4 functions marked with TODO comments.

## CUSTOMIZATION SECTION Functions (Graph Pattern)

### 1. define_graph_structure()
Return nodes and edges for Demo Viewer visualization:
```python
def define_graph_structure() -> Dict[str, Any]:
    return {
        "nodes": [{"id": "agent_id", "name": "Display Name", "type": "role_type"}],
        "edges": [{"from": "source", "to": "target", "condition": "description"}]
    }
```

### 2. get_entry_agent()
Return the ID of the first agent to invoke:
```python
def get_entry_agent() -> str:
    return "entry_agent_id"
```

### 3. route_to_next_agent()
Configure routing using the appropriate strategy:

**Strategy 1 - Explicit Routing** (agent returns `route_to` field):
- Agent prompt must include: "Return JSON with route_to field containing next agent ID or null"
- Template checks `response.get('route_to')` automatically

**Strategy 2 - Classification Routing** (agent returns `classification` field):
- Fill in `CLASSIFICATION_ROUTES` dict in main.py
- Agent prompt must include: "Return JSON with classification field"

**Strategy 3 - Static Routing** (predetermined sequence):
- Fill in `STATIC_ROUTES` dict in main.py
- No agent prompt changes needed

### 4. get_agent_display_name()
Map agent IDs to human-readable names.

## IMPORTANT: Agent Prompt Updates Required

If using Explicit or Classification routing, you MUST also update agent prompts to return structured JSON.
See the agent items above for the required response format.

Reference: .kiro/steering/tech.md for agent design and routing pattern.
\`\`\`

**Acceptance Criteria (Graph):**
- [ ] CUSTOMIZATION SECTION is filled in (file not recreated)
- [ ] `define_graph_structure()` returns nodes/edges from tech.md
- [ ] `get_entry_agent()` returns valid agent ID
- [ ] `route_to_next_agent()` uses CLASSIFICATION_ROUTES or STATIC_ROUTES (no keyword matching)
- [ ] `get_agent_display_name()` maps all agent IDs
- [ ] GENERIC INFRASTRUCTURE section is UNCHANGED
- [ ] `python agents/main.py --help` works

---

### IF confirmedOrchestration == "swarm":

**Purpose:** Customize the pre-bundled Swarm orchestrator with agent definitions.

**Depends on:** Items 1 through N-1

**Files to be MODIFIED (not created):**
- `agents/main.py` — PRE-BUNDLED Swarm orchestrator, customize CUSTOMIZATION SECTION only

**Prompt for Kiro — Copy everything in the code block below and paste into Kiro chat:**

\`\`\`
Customize the pre-bundled Swarm orchestrator for this Agentify project.

## CRITICAL: DO NOT RECREATE agents/main.py

The `agents/main.py` file is **PRE-BUNDLED** by the Agentify extension.
It already contains CLI parsing, event emission, `invoke_agent_remotely()`, and `extract_handoff_from_response()`.

**You ONLY need to modify the CUSTOMIZATION SECTION** — the 3 functions marked with TODO comments.

## CUSTOMIZATION SECTION Functions (Swarm Pattern)

### 1. define_graph_structure()
Return nodes and all possible handoff edges for Demo Viewer:
```python
def define_graph_structure() -> Dict[str, Any]:
    return {
        "nodes": [{"id": "agent_id", "name": "Display Name", "type": "coordinator|specialist"}],
        "edges": [{"from": "source", "to": "target", "condition": "handoff"}]
    }
```
Note: Show ALL possible handoffs — actual path is determined at runtime by agent decisions.

### 2. get_entry_agent()
Return the ID of the first agent (usually a coordinator):
```python
def get_entry_agent() -> str:
    return "coordinator"
```

### 3. get_agent_display_name()
Map agent IDs to human-readable names.

## IMPORTANT: Agent Handoff Tool Required

Every Swarm agent MUST have a `handoff_to_agent` tool to enable autonomous handoffs:

```python
@tool
@instrument_tool
def handoff_to_agent(agent_id: str, context: str) -> dict:
    '''Hand off to another agent with context.'''
    return {"handoff_to": agent_id, "context": context}
```

Agent prompts MUST instruct agents to use this tool when handing off, OR return JSON with `handoff_to` field.

Reference: .kiro/steering/tech.md for agent design and handoff patterns.
\`\`\`

**Acceptance Criteria (Swarm):**
- [ ] CUSTOMIZATION SECTION is filled in (file not recreated)
- [ ] `define_graph_structure()` shows all possible handoff paths
- [ ] `get_entry_agent()` returns valid coordinator agent ID
- [ ] `get_agent_display_name()` maps all agent IDs
- [ ] Each agent has `handoff_to_agent` tool OR returns `handoff_to` in response
- [ ] GENERIC INFRASTRUCTURE section is UNCHANGED
- [ ] `python agents/main.py --help` works

---

### IF confirmedOrchestration == "workflow":

**Purpose:** Customize the pre-bundled Workflow orchestrator with task DAG and dependencies.

**Depends on:** Items 1 through N-1

**Files to be MODIFIED (not created):**
- `agents/main.py` — PRE-BUNDLED Workflow orchestrator, customize CUSTOMIZATION SECTION only

**Prompt for Kiro — Copy everything in the code block below and paste into Kiro chat:**

\`\`\`
Customize the pre-bundled Workflow orchestrator for this Agentify project.

## CRITICAL: DO NOT RECREATE agents/main.py

The `agents/main.py` file is **PRE-BUNDLED** by the Agentify extension.
It already contains CLI parsing, event emission, parallel execution with ThreadPoolExecutor, and DAG validation.

**You ONLY need to modify the CUSTOMIZATION SECTION** — the 4 functions marked with TODO comments.

## CUSTOMIZATION SECTION Functions (Workflow Pattern)

### 1. define_graph_structure()
Return nodes and dependency edges for Demo Viewer:
```python
def define_graph_structure() -> Dict[str, Any]:
    return {
        "nodes": [{"id": "task_id", "name": "Task Name", "type": "task"}],
        "edges": [{"from": "dependency", "to": "dependent", "condition": "dependency"}]
    }
```

### 2. define_task_dag()
Return task dependencies as a Directed Acyclic Graph:
```python
def define_task_dag() -> Dict[str, List[str]]:
    return {
        "fetch_data": [],                    # No deps - runs first
        "analyze": ["fetch_data"],           # Waits for fetch_data
        "enrich": ["fetch_data"],            # Runs parallel with analyze
        "aggregate": ["analyze", "enrich"],  # Waits for both
    }
```
Tasks with empty dependency lists run immediately. Tasks run in parallel when their dependencies are satisfied.

### 3. get_agent_display_name()
Map task IDs to human-readable names.

### 4. build_task_prompt()
Customize how dependency results are passed to dependent tasks:
```python
def build_task_prompt(task_id: str, original_prompt: str,
                     dependency_results: Dict[str, Dict[str, Any]]) -> str:
    # Default: Include all dependency responses in prompt
    # Customize if tasks need specific data extraction
```

## IMPORTANT: No Routing Logic Needed

Workflow pattern uses the DAG structure for execution order — agents do NOT need to return routing fields.
All tasks in the DAG will execute; the only question is WHEN (after dependencies complete).

If you want structured data flow between tasks, agents CAN return JSON, but it's optional.

Reference: .kiro/steering/tech.md for task dependencies and parallel execution design.
\`\`\`

**Acceptance Criteria (Workflow):**
- [ ] CUSTOMIZATION SECTION is filled in (file not recreated)
- [ ] `define_graph_structure()` shows dependency edges
- [ ] `define_task_dag()` returns valid DAG (no cycles, all deps exist)
- [ ] `get_agent_display_name()` maps all task IDs
- [ ] `build_task_prompt()` properly passes dependency results
- [ ] GENERIC INFRASTRUCTURE section is UNCHANGED
- [ ] `python agents/main.py --help` works

---

## Final Checklist

Before outputting the roadmap, verify:

### Architecture & Deployment
1. [ ] Every prompt includes the full CRITICAL ARCHITECTURE block
2. [ ] Every agent item's prompt mentions "deploys to AgentCore Runtime"
3. [ ] Every agent item's acceptance criteria includes `agentcore deploy` command
4. [ ] The main.py item's prompt explicitly states to MODIFY (not CREATE) the file
5. [ ] The main.py item uses the correct pattern-specific section (Graph/Swarm/Workflow)
6. [ ] The main.py item's prompt specifies the correct CUSTOMIZATION SECTION functions for the pattern

### Pattern-Specific Requirements
7. [ ] **Graph pattern**: Agent items mention required response format (route_to or classification field)
8. [ ] **Graph pattern**: main.py item mentions CLASSIFICATION_ROUTES or STATIC_ROUTES (no keyword matching)
9. [ ] **Swarm pattern**: Agent items include `handoff_to_agent` tool definition
10. [ ] **Swarm pattern**: Agent prompts instruct using handoff tool OR returning `handoff_to` field
11. [ ] **Workflow pattern**: main.py item includes `define_task_dag()` function
12. [ ] **Workflow pattern**: Agent items do NOT mention routing fields (DAG determines order)

### Instrumentation & Observability
13. [ ] Pre-bundled files section explains `agents/shared/` AND `agents/main.py` are pre-bundled
14. [ ] Every agent item requires importing @instrument_tool from agents.shared.instrumentation (pre-bundled)
15. [ ] Every agent item shows correct decorator order: @tool ON TOP, @instrument_tool BELOW (closest to function)
16. [ ] Agent handlers (agents/{agent_id}_handler.py) set/clear instrumentation context

### CDK Structure & Injection
17. [ ] Gateway Lambda handlers use path `cdk/gateway/handlers/{tool_name}/` (with `cdk/` prefix)
18. [ ] Each Lambda handler directory contains `mock_data.json` (bundled, not external reference)
19. [ ] Lambda handler example loads mock data from same directory: `os.path.dirname(__file__)`
20. [ ] Pre-existing CDK structure is clearly documented (stacks/, app.py, config.py)
21. [ ] "What NOT to Create" section explicitly lists `cdk/stacks/*.py` as off-limits
22. [ ] No references to `gateway/handlers/` without the `cdk/` prefix
23. [ ] No references to external `mocks/` directory for Lambda handlers

### Dependencies & Order
24. [ ] Items are ordered: Gateway handlers → agents → orchestrator (shared utilities are pre-bundled)
25. [ ] No item assumes local-only execution for agents
26. [ ] All tools are mocks (demo system)
27. [ ] Event emission patterns are referenced in each prompt

### Path Consistency
28. [ ] All paths use forward slashes (not backslashes)
29. [ ] Agent modules go in `agents/{agent_id}/` directory
30. [ ] Agent handlers go in `agents/{agent_id}_handler.py`
31. [ ] Lambda handlers go in `cdk/gateway/handlers/` directory
32. [ ] No TypeScript references (CDK is Python: `cdk/stacks/gateway_tools.py`)

### Cedar Policies & Policy Engine (Conditional)
33. [ ] IF `policies/main.cedar` exists, include note in "How to Use This Roadmap" section
34. [ ] Policy Engine setup is documented as handled by `setup.sh`, NOT a Kiro item
35. [ ] Do NOT generate a separate roadmap item for Policy Engine creation
36. [ ] If Cedar policies exist, explain their purpose (access control from Step 4 security inputs)

## Output

Generate the complete `roadmap.md` content following the structure above. The output should be ready to write directly to `.kiro/steering/roadmap.md`.
