/**
 * Configuration types for Agentify projects
 * Defines the schema for .agentify/config.json
 *
 * Agentify uses a single deployment model: local subprocess execution.
 * The orchestration runs locally via agents/main.py, which calls agents
 * deployed to Bedrock AgentCore via Strands SDK.
 */

/**
 * Project configuration
 * Defines the business context for the Agentify project
 */
export interface ProjectConfig {
  /**
   * Human-readable project name
   * @example "Customer Service Agent"
   */
  name: string;

  /**
   * Customer value map describing the project's purpose
   * @example "Reduce customer wait times and improve satisfaction"
   */
  valueMap: string;

  /**
   * Industry vertical for domain-specific templates and prompts
   * @example "retail", "fsi", "healthcare", "tech"
   */
  industry: string;
}

/**
 * DynamoDB infrastructure configuration
 * Specifies the table used for workflow event storage
 */
export interface DynamoDbInfrastructureConfig {
  /**
   * Name of the DynamoDB table
   * @example "agentify-workflow-events"
   */
  tableName: string;

  /**
   * ARN of the DynamoDB table
   * @example "arn:aws:dynamodb:us-east-1:123456789012:table/agentify-workflow-events"
   */
  tableArn: string;

  /**
   * AWS region where the table is deployed
   * @example "us-east-1"
   */
  region: string;
}

/**
 * Infrastructure configuration
 * Contains all infrastructure-related settings
 */
export interface InfrastructureConfig {
  /**
   * DynamoDB configuration for workflow events
   */
  dynamodb: DynamoDbInfrastructureConfig;
}

/**
 * Agent definition within a workflow
 * Represents a single agent node in the workflow graph
 */
export interface AgentDefinition {
  /**
   * Unique identifier for the agent within the workflow
   * @example "research-agent"
   */
  id: string;

  /**
   * Human-readable display name
   * @example "Research Agent"
   */
  name: string;

  /**
   * Description of the agent's role in the workflow
   * @example "Gathers and analyzes relevant information"
   */
  role: string;
}

/**
 * Edge definition connecting agents in the workflow
 * Represents data flow between agent nodes
 */
export interface EdgeDefinition {
  /**
   * ID of the source agent node
   */
  from: string;

  /**
   * ID of the target agent node
   */
  to: string;
}

/**
 * Orchestration pattern for workflow execution
 * - 'graph': Directed acyclic graph with explicit edges
 * - 'swarm': Dynamic agent coordination
 * - 'workflow': Sequential step-by-step execution
 */
export type OrchestrationPattern = 'graph' | 'swarm' | 'workflow';

/**
 * Workflow configuration
 * Defines the workflow structure and agent composition
 *
 * The Demo Viewer spawns the entry script as a subprocess with CLI args:
 * --prompt, --workflow-id, --trace-id
 */
export interface WorkflowConfig {
  /**
   * Path to the entry script relative to workspace root
   * Generated by Kiro spec-driven development
   * @example "agents/main.py"
   */
  entryScript: string;

  /**
   * Path to the Python interpreter
   * @example ".venv/bin/python" or "python3"
   */
  pythonPath: string;

  /**
   * Orchestration pattern for the workflow
   * Determines how agents coordinate:
   * - 'graph': Deterministic structure with LLM-driven path selection
   * - 'swarm': Autonomous agent collaboration with emergent handoffs
   * - 'workflow': Fixed DAG execution with automatic parallelization
   */
  orchestrationPattern: OrchestrationPattern;

  /**
   * List of agents that compose the workflow
   */
  agents: AgentDefinition[];

  /**
   * Edges defining data flow between agents (for graph patterns)
   */
  edges: EdgeDefinition[];
}

/**
 * AWS configuration for credential and profile management
 * Allows project-level override of AWS profile selection
 */
export interface AwsConfig {
  /**
   * AWS CLI profile name to use for credentials
   * When specified, this profile is passed to the AWS SDK credential provider chain.
   * When omitted, the SDK uses default behavior (AWS_PROFILE env var or 'default' profile).
   * @example "my-dev-profile"
   */
  profile?: string;
}

/**
 * Bedrock configuration for Claude API integration
 * Controls the model used for ideation assistance
 */
export interface BedrockConfig {
  /**
   * Bedrock model ID for Claude API calls
   * When omitted, defaults to `global.anthropic.claude-sonnet-4-5-20250929-v1:0` (Sonnet for cost efficiency)
   * @example "global.anthropic.claude-sonnet-4-5-20250929-v1:0"
   */
  modelId?: string;
}

/**
 * Configuration for observability features
 */
export interface ObservabilityConfig {
  /**
   * AWS X-Ray console URL template
   * Supports {region} and {trace_id} placeholders
   * @example "https://{region}.console.aws.amazon.com/xray/home?region={region}#/traces/{trace_id}"
   */
  xrayConsoleUrl?: string;
}

/**
 * Root configuration for an Agentify project
 * Stored in .agentify/config.json
 */
export interface AgentifyConfig {
  /**
   * Configuration schema version for forward compatibility
   * @example "1.0.0"
   */
  version: string;

  /**
   * Project metadata and business context
   */
  project: ProjectConfig;

  /**
   * Infrastructure settings (DynamoDB, etc.)
   */
  infrastructure: InfrastructureConfig;

  /**
   * Workflow definition and trigger configuration
   */
  workflow: WorkflowConfig;

  /**
   * AWS configuration for credential and profile management
   * Optional - when omitted, AWS SDK uses default credential resolution
   */
  aws?: AwsConfig;

  /**
   * Bedrock configuration for Claude API integration
   * Optional - when omitted, uses default model (Sonnet)
   */
  bedrock?: BedrockConfig;

  /**
   * Observability configuration (X-Ray, tracing)
   * Optional - when omitted, observability features are disabled
   */
  observability?: ObservabilityConfig;
}

/**
 * Result of configuration validation
 */
export interface ConfigValidationResult {
  /**
   * Whether the configuration is valid
   */
  isValid: boolean;

  /**
   * Array of validation error messages (empty if valid)
   */
  errors: string[];
}

/**
 * Validates that a config object has all required fields
 * @param config The config object to validate
 * @returns Validation result with isValid flag and any errors
 */
export function validateConfigSchema(config: unknown): ConfigValidationResult {
  const errors: string[] = [];

  if (!config || typeof config !== 'object') {
    return { isValid: false, errors: ['Configuration must be an object'] };
  }

  const cfg = config as Record<string, unknown>;

  // Validate version
  if (typeof cfg.version !== 'string') {
    errors.push('Missing or invalid "version" field');
  }

  // Validate project
  if (!cfg.project || typeof cfg.project !== 'object') {
    errors.push('Missing or invalid "project" field');
  } else {
    const project = cfg.project as Record<string, unknown>;
    if (typeof project.name !== 'string') {
      errors.push('Missing or invalid "project.name" field');
    }
    if (typeof project.valueMap !== 'string') {
      errors.push('Missing or invalid "project.valueMap" field');
    }
    if (typeof project.industry !== 'string') {
      errors.push('Missing or invalid "project.industry" field');
    }
  }

  // Validate infrastructure
  if (!cfg.infrastructure || typeof cfg.infrastructure !== 'object') {
    errors.push('Missing or invalid "infrastructure" field');
  } else {
    const infra = cfg.infrastructure as Record<string, unknown>;
    if (!infra.dynamodb || typeof infra.dynamodb !== 'object') {
      errors.push('Missing or invalid "infrastructure.dynamodb" field');
    } else {
      const dynamodb = infra.dynamodb as Record<string, unknown>;
      if (typeof dynamodb.tableName !== 'string') {
        errors.push('Missing or invalid "infrastructure.dynamodb.tableName" field');
      }
      if (typeof dynamodb.tableArn !== 'string') {
        errors.push('Missing or invalid "infrastructure.dynamodb.tableArn" field');
      }
      if (typeof dynamodb.region !== 'string') {
        errors.push('Missing or invalid "infrastructure.dynamodb.region" field');
      }
    }
  }

  // Validate workflow
  if (!cfg.workflow || typeof cfg.workflow !== 'object') {
    errors.push('Missing or invalid "workflow" field');
  } else {
    const workflow = cfg.workflow as Record<string, unknown>;

    // entryScript is optional (filled in after Kiro generates main.py)
    if (workflow.entryScript !== undefined && typeof workflow.entryScript !== 'string') {
      errors.push('Invalid "workflow.entryScript" - must be a string when provided');
    }

    // pythonPath is optional (defaults to "python3" if not specified)
    if (workflow.pythonPath !== undefined && typeof workflow.pythonPath !== 'string') {
      errors.push('Invalid "workflow.pythonPath" - must be a string when provided');
    }

    // orchestrationPattern is optional with default
    const validPatterns = ['graph', 'swarm', 'workflow'];
    if (workflow.orchestrationPattern !== undefined &&
        !validPatterns.includes(workflow.orchestrationPattern as string)) {
      errors.push('Invalid "workflow.orchestrationPattern" - must be "graph", "swarm", or "workflow"');
    }

    // agents and edges are optional arrays
    if (workflow.agents !== undefined && !Array.isArray(workflow.agents)) {
      errors.push('Invalid "workflow.agents" - must be an array when provided');
    }
    if (workflow.edges !== undefined && !Array.isArray(workflow.edges)) {
      errors.push('Invalid "workflow.edges" - must be an array when provided');
    }
  }

  // Validate optional aws section (backward compatible - section can be omitted)
  if (cfg.aws !== undefined) {
    if (typeof cfg.aws !== 'object' || cfg.aws === null) {
      errors.push('Invalid "aws" field - must be an object when provided');
    } else {
      const aws = cfg.aws as Record<string, unknown>;
      // Validate aws.profile when provided (optional field)
      if (aws.profile !== undefined) {
        if (typeof aws.profile !== 'string') {
          errors.push('Invalid "aws.profile" field - must be a string when provided');
        } else if (aws.profile.trim() === '') {
          errors.push('Invalid "aws.profile" field - must be a non-empty string when provided');
        }
      }
    }
  }

  // Validate optional bedrock section (backward compatible - section can be omitted)
  if (cfg.bedrock !== undefined) {
    if (typeof cfg.bedrock !== 'object' || cfg.bedrock === null) {
      errors.push('Invalid "bedrock" field - must be an object when provided');
    } else {
      const bedrock = cfg.bedrock as Record<string, unknown>;
      // Validate bedrock.modelId when provided (optional field)
      if (bedrock.modelId !== undefined) {
        if (typeof bedrock.modelId !== 'string') {
          errors.push('Invalid "bedrock.modelId" field - must be a string when provided');
        } else if (bedrock.modelId.trim() === '') {
          errors.push('Invalid "bedrock.modelId" field - must be a non-empty string when provided');
        }
      }
    }
  }

  return {
    isValid: errors.length === 0,
    errors,
  };
}
