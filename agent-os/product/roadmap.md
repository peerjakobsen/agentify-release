# Product Roadmap

## Phase 1: Foundation (MVP)

1. [x] DynamoDB Observability Table — Create `agentify-workflow-events` DynamoDB table with workflow_id partition key, timestamp sort key, event_type, agent_name, payload, and TTL configuration `S`

2. [x] Agentify Extension Shell — Create single Kiro IDE extension with shared services (AWS clients, config, types) and registration for two webview panels: Demo Viewer (runtime) and Ideation Wizard (design-time) `S`

3. [x] AWS Credential Chain Integration — Use AWS SDK's default credential provider chain to automatically consume credentials from shared AWS config files (~/.aws/credentials, ~/.aws/config), supporting IAM credentials, IAM Identity Center (SSO), and assumed roles configured via AWS CLI or AWS Toolkit; add project-level region configuration in .agentify/config.json for DynamoDB and Bedrock API calls `S`

4. [x] Project Initialization Command — Add "Agentify: Initialize Project" command that: (1) checks AWS credentials via default credential chain, (2) validates DynamoDB table exists using tableValidator service, (3) if table missing, prompts user to deploy using bundled `infrastructure/dynamodb-table.yaml` template via CloudFormation SDK, (4) waits for stack CREATE_COMPLETE, (5) generates `.agentify/config.json` with table name, region, and stack name, (6) creates `.kiro/steering/agentify-integration.md` steering file. The CloudFormation template from spec #1 is packaged with the extension for automated deployment. `M`

5. [x] Workflow Input Panel — Build Demo Viewer input panel with: (1) multi-line prompt textarea (button submit only, no Enter shortcut), (2) Run Workflow button that spawns `agents/main.py` with `--prompt`, `--workflow-id`, and `--trace-id` CLI args, (3) hybrid identity display showing short `workflow_id` (wf-xxx) with copy button and OTEL `trace_id` with optional X-Ray console link, (4) execution timer, (5) validation states for missing entry script or AWS credentials. The `main.py` is generated by Kiro spec-driven development, not by this extension. `M`

6. [x] Execution Log Panel — Create chronological log panel displaying events from DynamoDB with timestamps, event types, agent names, and expandable payload details `M`

7. [x] Outcome Panel — Build outcome display section in Demo Viewer (below Execution Log) showing: (1) success/failure status with ✅/❌ icon from `workflow_complete` or `workflow_error` stdout events, (2) workflow result rendered as markdown when result is a string, with formatted JSON fallback (syntax highlighting, collapsible) for structured objects, (3) "Sources" line listing data sources used if provided in outcome payload, (4) copy-to-clipboard button for result content. Panel starts hidden/collapsed until first workflow completes, clears immediately when new run starts (not waiting for new outcome). Error state displays error message prominently without stack trace — keep it clean for demo audiences. Does NOT duplicate execution duration (already shown in Input Panel timer). `S`

8. [x] DynamoDB Polling Service — Implement polling service for workflow events: (1) poll `infrastructure.dynamodb.tableName` every 500ms using AWS SDK DocumentClient, (2) query by `workflow_id` (partition key) with `timestamp` (sort key) greater than last-polled timestamp to fetch only new events, (3) start polling when `handleRunWorkflow()` generates a workflow_id, (4) stop polling on `workflow_complete`/`workflow_error` event, panel dispose, or new workflow run, (5) exponential backoff on errors (1s, 2s, 4s, max 30s) with automatic recovery, (6) emit events to subscribers (for merging with stdout stream), (7) track seen event IDs for deduplication. Service is separate from panel lifecycle — panel subscribes to events, service manages AWS calls. `M`

9. [ ] Observability Steering Documentation — Expand `.kiro/steering/agentify-integration.md` (created in item 4) with complete implementation guidance for Kiro-generated agent code:

**CLI Contract:**
- `agents/main.py` must accept `--prompt`, `--workflow-id`, `--trace-id` via argparse
- Read `AGENTIFY_TABLE_NAME` and `AGENTIFY_TABLE_REGION` environment variables
- Example argparse setup code snippet

**Hybrid Identity Pattern:**
- `workflow_id`: Short ID (wf-{8-char}) for UI display and DynamoDB partition key
- `trace_id`: 32-char hex OTEL trace ID for X-Ray correlation
- Both IDs included in every emitted event

**stdout Event Streaming (real-time, for graph visualization):**
- JSON Lines format (one JSON object per line to stdout)
- Event types: `graph_structure` (topology at start), `node_start`/`node_stream`/`node_stop` (agent lifecycle), `workflow_complete`/`workflow_error` (terminal)
- Schema: `{"workflow_id": "...", "trace_id": "...", "timestamp": 1234567890, "event_type": "...", "payload": {...}}`
- Example: mapping Strands `stream_async()` callbacks to stdout events

**DynamoDB Event Persistence (for tool calls and history):**
- Event types: `tool_call`, `tool_result`, `agent_start`, `agent_end`, `handoff`
- Write to table from `AGENTIFY_TABLE_NAME` env var using boto3
- Include TTL field for automatic cleanup
- Example: `emit_event()` helper function pattern

**Strands SDK Integration:**
- `StrandsTelemetry` setup for OTEL trace propagation
- `stream_async()` event callback mapping to stdout JSON lines
- Agent decorator patterns for consistent event emission

This steering file is the source of truth for Kiro's code generation — all generated agents must follow these patterns. `M`

10. [ ] Workflow Trigger Service — Build subprocess execution service that: (1) generates `workflow_id` (wf-{8-char-uuid}) and OTEL-compatible `trace_id` (32-char hex), (2) spawns `python {entryScript}` with CLI args from config, (3) passes `AGENTIFY_TABLE_NAME` and `AGENTIFY_TABLE_REGION` env vars, (4) captures stdout for real-time event streaming, (5) handles process lifecycle (start, running, exit, error, kill on reset). Entry script path read from `.agentify/config.json` workflow.entryScript field. `M`

11. [ ] stdout Event Streaming — Parse real-time JSON line events from subprocess stdout following the schema defined in `agentify-integration.md`: `graph_structure` (topology at start), `node_start`/`node_stream`/`node_stop` (mapped from Strands `multiagent_*` events), `tool_call`/`tool_result`, and `workflow_complete`/`workflow_error`. Each event includes `workflow_id`, `trace_id`, `timestamp`, `event_type`, and `payload`. `M`

12. [ ] Merged Event Stream Service — Combine stdout events (real-time graph updates) with DynamoDB events (tool calls, persistent history) into unified event stream for Demo Viewer panels `S`

## Phase 2: AI-Assisted Ideation

13. [ ] Ideation Wizard Panel — Add Ideation Wizard webview panel to the Agentify extension with multi-step wizard UI, leveraging shared AWS services and configuration `S`

14. [ ] Business Objective Input UI — Build first wizard step with: (1) multi-line text input for business objective/problem statement, (2) industry vertical dropdown, (3) system checkboxes (SAP, Salesforce, Databricks, etc.), (4) optional file upload for additional context (account plan, requirements doc). Claude uses this context to propose agent designs. `M`

15. [ ] Claude Bedrock Integration — Implement Amazon Bedrock client for Claude API calls with conversation context management and streaming response handling `M`

16. [ ] AI Gap-Filling Conversation — Create conversational UI where Claude proposes industry-typical configurations based on selected systems and industry, with user refinement capability `L`

17. [ ] Outcome Definition Step — Build wizard step for defining measurable business outcomes, success criteria, and KPIs that map to the business objective `S`

18. [ ] Security & Guardrails Step — Build wizard step for compliance considerations, human approval gate placement, and data sensitivity classification `S`

19. [ ] Agent Design Phase — Create wizard step where Claude proposes agent team composition with roles, responsibilities, and recommends optimal Strands orchestration pattern (Graph for conditional routing, Swarm for autonomous collaboration, Workflow for deterministic pipelines) based on the business objective complexity and coordination requirements `L`

20. [ ] Agent Design Refinement — Add UI for user to accept, modify, or reject proposed agents and adjust orchestration flow `M`

21. [ ] Orchestration Pattern Selection — Interactive UI for selecting between Strands Graph, Swarm, or Workflow patterns with AI-assisted recommendation explaining tradeoffs for the specific business objective scenario, visual preview of how agents will coordinate under each pattern, and pattern-specific configuration (Graph: edge conditions, Swarm: handoff rules, Workflow: task dependencies) `M`

22. [ ] Mock Data Strategy — Implement AI-generated mock data shapes based on industry context and selected systems for realistic demo scenarios `M`

## Phase 3: Visual Polish

23. [ ] Agent Graph Visualization — Add React Flow visualization to Demo Viewer with custom node components showing agent status (pending/running/completed/failed), animated edges during data flow, auto-layout via dagre/elkjs, and pattern-specific layouts: Graph (DAG with conditional edges), Swarm (peer-to-peer), Workflow (parallel execution lanes) `L`

24. [ ] Graph Animation — Implement real-time graph updates from stdout events with smooth transitions as agents activate, complete, and hand off work `M`

25. [ ] Enhanced Log Formatting — Add collapsible sections, syntax highlighting for payloads, and filtering by agent name or event type `M`

26. [ ] Demo Design Phase — Create wizard step for capturing key "aha moments", demo persona definition, and narrative flow sequencing `M`

27. [ ] Wizard State Persistence — Implement workspace storage for wizard progress so users can resume incomplete ideation sessions `S`

## Phase 4: Kiro Integration & Enforcement

28. [ ] Core Steering Files Generation — Generate `product.md` (business objective context), `tech.md` (Strands SDK, Python, selected orchestration pattern), `structure.md` (standard agentic project layout) from wizard context `M`

29. [ ] Context Steering Files Generation — Generate `customer-context.md` (industry, strategic priorities), `integration-landscape.md` (systems, data sources, mock definitions), `security-policies.md` (compliance, approval gates), `demo-strategy.md` (key moments, narrative, mock data approach) from ideation outputs `M`

30. [ ] Kiro Steering Generation — Generate complete `.kiro/steering/` directory from wizard state: `product.md` (business objective as product description), `tech.md` (AgentCore, Strands SDK, Python, DynamoDB stack), `structure.md` (standard agentic project layout), `customer-context.md` (industry, objective, priorities), `integration-landscape.md` (systems, mock definitions), `security-policies.md` (guardrails, approval gates), `demo-strategy.md` (key moments, narrative, mock data approach), `agentify-integration.md` (event emission patterns, CLI contract). `M`

31. [ ] Agentify Power Package — Create Kiro Power that bundles: (1) `POWER.md` steering file with agentic workflow best practices, event emission patterns, and CLI contract requirements, (2) enforcement hooks for code validation. Power activates when keywords like "agent", "workflow", "Strands", "orchestrator", or "demo" are mentioned. Structure: `agentify-power/POWER.md`, `agentify-power/hooks/*.kiro.hook`. Power can be installed via Kiro's power import from the extension's bundled directory or published to community powers. `M`

32. [ ] Observability Enforcement Hook — Create `observability-enforcer.kiro.hook` that triggers on `fileSaved` for `agents/*.py` pattern: validates event emission patterns match `agentify-integration.md` contract, checks for proper `emit_event()` calls in agent functions, suggests missing observability code. Hook prompt references steering file for expected patterns. `S`

33. [ ] CLI Contract Validation Hook — Create `cli-contract-validator.kiro.hook` that triggers on `fileSaved` for `agents/main.py`: validates CLI argument parsing includes `--prompt`, `--workflow-id`, `--trace-id` parameters, checks for proper `argparse` setup, validates environment variable reading for `AGENTIFY_TABLE_NAME` and `AGENTIFY_TABLE_REGION`. `S`

34. [ ] Mock Tool Pattern Hook — Create `mock-tool-pattern.kiro.hook` that triggers on `fileCreated` for `tools/*.py` pattern: ensures new tool files include Strands `@tool` decorator, validates mock data structure matches industry context from `integration-landscape.md`, suggests realistic mock response shapes. `S`

35. [ ] Power Installation Integration — Update Ideation Wizard's steering generation (Item 30) to also install/activate the Agentify Power when writing steering files, ensuring hooks are active before Kiro begins code generation. Add power manifest to `.kiro/powers/agentify/` or register via Kiro's power import mechanism. `S`

36. [ ] Kiro Spec Trigger — Implement seamless handoff that: (1) ensures Agentify Power is installed/activated, (2) validates all steering files are complete, (3) opens Kiro spec mode with generated artifacts pre-loaded, (4) displays confirmation that enforcement hooks are active. Gracefully degrades in VS Code with message directing user to Kiro. `S`

## Phase 5: Templates and Patterns

37. [ ] Industry Template Framework — Build template system for storing and loading pre-built agent patterns with metadata `M`

38. [ ] Retail Industry Template — Create agent patterns for common retail scenarios: inventory optimization, customer service, demand forecasting `M`

39. [ ] FSI Industry Template — Create agent patterns for financial services: fraud detection, customer onboarding, risk assessment `M`

40. [ ] Healthcare Industry Template — Create agent patterns for healthcare: patient scheduling, claims processing, clinical decision support `M`

41. [ ] Manufacturing Industry Template — Create agent patterns for manufacturing: predictive maintenance, quality control, supply chain optimization `M`

42. [ ] Value Map Template Framework — Build storage and loading system for value map templates with metadata schema including recommended orchestration pattern `M`

43. [ ] Common Value Map Templates — Create templates for common value maps, each with suggested agent teams and recommended Strands pattern: Cost Reduction (typically Workflow for deterministic optimization pipeline), Revenue Growth (typically Graph for conditional customer journey routing), Operational Efficiency (typically Workflow for parallel automation tasks), Customer Experience (typically Swarm for collaborative issue resolution), Risk Mitigation (typically Graph for decision trees with approval gates) `L`

44. [ ] Demo Script Generator — Create AI-powered talking points generator that produces demo narrative aligned with business objective and agent design `M`

## Phase 6: Enterprise Features

45. [ ] Demo Library Storage — Implement cloud storage for saving completed demos with metadata, tags, and search capability `L`

46. [ ] Demo Sharing — Add team sharing functionality with permissions and version tracking for collaborative demo development `M`

47. [ ] Demo Analytics — Build tracking for demo usage metrics: runs, customer reactions, conversion correlation `L`

48. [ ] Multi-Region Deployment — Add region selector and deployment automation for production deployments in us-east-1, us-west-2, eu-west-1 `M`

49. [ ] Demo Export — Create export functionality for packaging demos as standalone artifacts for offline or customer-site execution `M`

---

## Notes

- Order items by technical dependencies and product architecture
- Each item should represent an end-to-end functional and testable feature
- Single Agentify extension with two webview panels: Demo Viewer (runtime visualization) and Ideation Wizard (design-time workflow)
- **Single deployment model**: Orchestration always runs locally via `agents/main.py`, which calls agents deployed to Bedrock AgentCore. There are no separate "local" vs "AgentCore" deployment modes.
- **Dual-mode event streaming** (not deployment):
  - **stdout streaming**: Real-time JSON lines from subprocess for graph visualization
  - **DynamoDB polling**: Persistent storage for tool calls and historical replay
- **Hybrid identity**: Each run has short `workflow_id` (wf-xxx for UI/DynamoDB) + OTEL `trace_id` (32-char hex for X-Ray correlation)
- **main.py generation**: The orchestration entry point is generated by Kiro spec-driven development following patterns in `agentify-integration.md`, not created by the Agentify extension
- Strands SDK provides native OpenTelemetry support via `StrandsTelemetry` - no custom decorator package needed
- Project config stored in `.agentify/config.json`, Kiro steering in `.kiro/steering/agentify-integration.md`
- "Agentify: Initialize Project" command must run before using the extension
- CloudFormation templates in `infrastructure/` are bundled with the extension for automated deployment
- Phase 1 establishes core infrastructure before building features that depend on it
- Phase 2 AI features require Bedrock integration from earlier items
- Phase 4 Kiro integration depends on wizard outputs from Phase 2-3
- Phase 5-6 are enhancement phases that can be prioritized based on customer feedback
- **Agentify Power**: Bundles steering guidance and enforcement hooks into a Kiro Power package that activates on-demand during agent development
- **Enforcement Hooks**: Automatically validate generated code follows Agentify patterns (event emission, CLI contract, mock tool structure) as files are saved
- Hooks reference steering files for validation rules, creating a closed loop between documentation and enforcement

## Technical References

- Strands Agents SDK: https://strandsagents.com/latest/
- Multi-agent patterns documentation: https://strandsagents.com/latest/documentation/docs/user-guide/concepts/multi-agent/multi-agent-patterns/
- Strands Observability/Traces: https://strandsagents.com/latest/documentation/docs/user-guide/observability-evaluation/traces/
- OpenTelemetry Context Propagation: https://opentelemetry.io/docs/concepts/context-propagation/
- W3C Trace Context (traceparent header): https://www.w3.org/TR/trace-context/
- Kiro Powers: https://kiro.dev/powers/ and https://kiro.dev/docs/powers/
- Kiro Hooks: https://kiro.dev/docs/hooks/ and https://kiro.dev/docs/hooks/types/
- Three orchestration patterns supported:
  - **Graph**: Deterministic structure with LLM-driven path selection, supports cycles, conditional edges
  - **Swarm**: Autonomous agent collaboration with emergent handoffs, supports cycles, shared context
  - **Workflow**: Fixed DAG execution with automatic parallelization, no cycles, task dependencies
