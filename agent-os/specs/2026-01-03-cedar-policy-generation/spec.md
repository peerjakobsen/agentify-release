# Specification: Cedar Policy Generation

## Goal
Transform Step 4 security inputs (data sensitivity, compliance frameworks, approval gates) and Step 5 agent/tool definitions into enforceable AgentCore Policy Engine Cedar policies, enabling runtime authorization control for MCP Gateway tool invocations.

## User Stories
- As a field team member, I want Cedar policies automatically generated from my wizard inputs so that I can enforce security controls without learning Cedar syntax
- As a demo presenter, I want policies to default to LOG_ONLY mode so that my demos run smoothly while showing policy decisions in logs

## Specific Requirements

**Cedar Policy Prompt File**
- Create new prompt file `resources/prompts/steering/cedar-policies.prompt.md`
- Follow existing steering prompt structure (system prompt with input schema and output format)
- Accept combined context from Step 4 (SecurityState) and Step 5 (AgentDesignState)
- Output raw Cedar policy syntax (not markdown-wrapped)
- Include examples for each compliance framework (HIPAA, PCI-DSS, GDPR, SOC 2, FedRAMP)
- Use `{{GATEWAY_ARN}}` placeholder for Gateway resource reference (replaced at deploy time)

**Cedar Syntax Requirements**
- Action format: `AgentCore::Action::"TargetName___tool_name"` (triple underscore separator)
- Resource format: `AgentCore::Gateway::"{{GATEWAY_ARN}}"`
- Principal type: Not used in v1 (Action + Gateway entity types only)
- Use `forbid` statements with forbid-wins semantics
- Use `.contains()` for multi-value claim checks (e.g., `context.claims.roles.contains("admin")`)
- Integer comparisons: use standard operators (`<`, `>`, `==`)
- Decimal comparisons: use method syntax (`.lessThan()`, `.greaterThan()`)

**Policy Context Mapper**
- Create new mapper function `mapToCedarPolicyContext()` in `src/utils/steeringStateMapper.ts`
- Extract from SecurityState: dataSensitivity, complianceFrameworks, approvalGates, guardrailNotes
- Extract from AgentDesignState: confirmedAgents with their tools arrays
- Build flat list of all tools across all agents for policy targeting
- Include agent-to-tool mapping for agent-specific policy generation

**SteeringGenerationService Updates**
- Add `generateCedarPolicies()` method following `generateDocument()` pattern
- Add Cedar prompt file key to `STEERING_PROMPT_FILES` mapping
- Generate Cedar policies in parallel with steering files during Step 8
- Emit progress events for policy files (integrate with existing UI status display)
- Output policies to `policies/` directory (separate from `.kiro/steering/`)

**Policy File Naming and Structure**
- Generate one `.cedar` file per policy category (e.g., `data-sensitivity.cedar`, `hipaa-compliance.cedar`)
- Include header comment with source information: `// Generated by Agentify from Step 4 security inputs`
- Include `// Example - expand for production` comment for compliance framework policies
- Use descriptive policy annotations for human readability

**Claim Name Conventions**
- Use intuitive generic claim names for field team accessibility
- Data sensitivity: `context.claims.clearance_level` (values: "public", "internal", "confidential", "restricted")
- Role-based: `context.claims.user_role`, `context.claims.department`
- Approval authority: `context.claims.approval_authority`
- Compliance: `context.claims.pci_certified`, `context.claims.hipaa_trained`
- Input context: `context.input.amount`, `context.input.data_category`

**Compliance Framework Policies**
- HIPAA: 2-3 policies covering PHI access requiring healthcare_provider role
- PCI-DSS: 2-3 policies for card data tools requiring pci_certified claim
- GDPR: 2-3 policies for EU data requiring consent claim present
- SOC 2: 2-3 policies for audit logging and access control
- FedRAMP: 2-3 policies for federal system boundary protection

**Configuration Schema Update**
- Add `policy` section to `AgentifyConfig` interface in `src/types/config.ts`
- Include `policyMode` field with type `"LOG_ONLY" | "ENFORCE"` (default: "LOG_ONLY")
- Include optional `policyEngineId` field (populated after deployment)
- Include optional `policyEngineArn` field (populated after deployment)

**setup.sh Step 2b Updates**
- Check for `policies/` directory with `.cedar` files before proceeding
- Create Policy Engine using `agentcore policy create-policy-engine`
- Load each `.cedar` file, replace `{{GATEWAY_ARN}}` placeholder with actual Gateway ARN
- Create policies using `agentcore policy create-policy` for each file
- Associate Policy Engine with Gateway using `agentcore gateway update-gateway`
- Read policy mode from `.agentify/config.json` (default: LOG_ONLY)
- Save Policy Engine ID and ARN to `.agentify/infrastructure.json`

**destroy.sh Step 1b Updates**
- Delete all policies from Policy Engine using `agentcore policy delete-policy`
- Delete Policy Engine using `agentcore policy delete-policy-engine`
- Remove Policy Engine entries from `.agentify/infrastructure.json`

## Existing Code to Leverage

**SteeringGenerationService (`src/services/steeringGenerationService.ts`)**
- Use `generateDocument()` pattern for Cedar generation (Bedrock ConverseCommand)
- Leverage existing prompt loading and caching via `loadPrompt()` method
- Follow `STEERING_PROMPT_FILES` mapping pattern for Cedar prompt file
- Use existing retry logic with exponential backoff for transient failures
- Emit events via `_onFileStart`, `_onFileComplete`, `_onFileError` for UI integration

**steeringStateMapper.ts (`src/utils/steeringStateMapper.ts`)**
- Follow `mapToSecurityContext()` pattern for extracting SecurityState fields
- Follow `mapToTechContext()` pattern for extracting AgentDesignState with tools
- Use `analyzeSharedTools()` utility for tool-to-agent mapping reference
- Create new `CedarPolicyContext` interface following existing context interface patterns

**security-policies-steering.prompt.md**
- Reference input schema for SecurityState fields (dataSensitivity, complianceFrameworks, approvalGates)
- Reference compliance framework control mappings (HIPAA, PCI-DSS, GDPR, SOC 2, FedRAMP)
- Reference approval gate patterns and Cedar action mappings

**setup.sh and destroy.sh Scripts**
- Step 2b Policy Engine logic already exists in setup.sh (lines 370-538)
- Step 1b Policy Engine deletion logic already exists in destroy.sh (lines 383-438)
- Use existing agentcore CLI patterns for policy management commands
- Follow existing jq patterns for JSON config manipulation

**config.ts (`src/types/config.ts`)**
- Follow existing interface patterns (RoutingConfig, ObservabilityConfig)
- Add validation for policy config in `validateConfigSchema()` function
- Use optional fields pattern for backward compatibility

## Out of Scope
- Custom Cedar editing UI in the wizard (users edit .cedar files in their IDE)
- Policy versioning or history tracking
- Policy testing/simulation before deployment (would require Cedar validator integration)
- External policy management or IAM integration
- Policy inheritance or composition (keep flat policy structure)
- Cross-Gateway policies (one Gateway per demo project)
- Policy templates marketplace
- Real-time policy debugging in Demo Viewer (CloudWatch logs sufficient for v1)
- Principal entity type support (agent identity requires authentication model)
- Demo Viewer integration for policy events (deferred to future iteration)
